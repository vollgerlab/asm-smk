from snakemake.utils import min_version
import pandas as pd
import numpy as np

min_version("9.0")

# read in the manifest of samples
tbl = pd.read_csv(
    config["manifest"],
    sep="\\s+",
    index_col=0,
    dtype={
        "sample": str,
        "hifi": str,
        "paternal": str,
        "maternal": str,
        "hic_r1": str,
        "hic_r2": str,
        "ultralong": str,
    },
)
# Add missing columns with NA defaults for backward compatibility
for col in ["hic_r1", "hic_r2", "ultralong"]:
    if col not in tbl.columns:
        tbl[col] = pd.NA

# the columns with reads can have multiple entries, so we need to split them
tbl["hifi"] = tbl["hifi"].str.split(",")
tbl["maternal"] = tbl["maternal"].str.split(",")
tbl["paternal"] = tbl["paternal"].str.split(",")
tbl["hic_r1"] = tbl["hic_r1"].str.split(",")
tbl["hic_r2"] = tbl["hic_r2"].str.split(",")
tbl["ultralong"] = tbl["ultralong"].str.split(",")
# make them lists even if they are empty


# include the helper functions
include: "rules/common.smk"


# make the references
REFS = set_references()


wildcard_constraints:
    sm="|".join(tbl.index),
    hap="|".join(["hap1", "hap2"]),
    asm_type="bp|dip|hic",
    parental="pat|mat",
    read_type="hifi|mat|pat|hic_r1|hic_r2|ultralong",
    idx=r"\d+",
    ref="|".join(REFS.keys()),


# include the rules
include: "rules/asm.smk"
include: "rules/align.smk"
include: "rules/variants.smk"


# Helper function to check if manifest value contains valid data
def is_valid_data(val):
    """Check if a manifest value contains valid data (not NA/empty)."""
    # Handle scalar NA values
    try:
        if pd.isna(val):
            return False
    except (ValueError, TypeError):
        # pd.isna fails on arrays/lists, continue to list handling
        pass
    # Handle lists
    if isinstance(val, (list, np.ndarray)):
        if len(val) == 0:
            return False
        return all(v and str(v).upper() != "NA" for v in val)
    # Handle scalar values
    return val and str(val).upper() != "NA"


# define the output files based on the assembly type
HAS_PARENTAL = {}
HAS_HIC = {}
HAS_ULTRALONG = {}
results = []
for row in tbl.itertuples():
    sm = row.Index

    has_parental = is_valid_data(row.paternal) and is_valid_data(row.maternal)
    has_hic = is_valid_data(row.hic_r1) and is_valid_data(row.hic_r2)
    has_ultralong = is_valid_data(row.ultralong)

    # VALIDATION: Mutual exclusivity - trio and Hi-C phasing cannot be combined
    if has_parental and has_hic:
        raise ValueError(
            f"Sample '{sm}': Cannot combine parental trio data (-1/-2) with Hi-C "
            f"data (--h1/--h2). These phasing modes are mutually exclusive in hifiasm."
        )

    # VALIDATION: Hi-C requires both R1 and R2
    hic_r1_valid = is_valid_data(row.hic_r1)
    hic_r2_valid = is_valid_data(row.hic_r2)
    if hic_r1_valid != hic_r2_valid:
        raise ValueError(
            f"Sample '{sm}': Hi-C requires paired-end reads. Provide both "
            f"hic_r1 and hic_r2 columns, or neither."
        )

    # Store flags
    HAS_PARENTAL[sm] = has_parental
    HAS_HIC[sm] = has_hic
    HAS_ULTRALONG[sm] = has_ultralong

    # Determine assembly type
    if has_parental:
        asm_type = "dip"
    elif has_hic:
        asm_type = "hic"
    else:
        asm_type = "bp"

    extra_info = ", with ultra-long reads" if has_ultralong else ""
    print(f"Processing {sm} with assembly type {asm_type}{extra_info}")

    # Add oriented assemblies (single orientation to primary reference)
    results += expand(
        rules.orient_assembly.output.fa,
        sm=sm,
        hap=["hap1", "hap2"],
        asm_type=asm_type,
    )
    # Add merged diploid assembly
    results += expand(
        rules.merge_haplotype_fasta.output.fa,
        sm=sm,
        asm_type=asm_type,
    )
    # Add PAF alignments and variants for ALL references
    for ref in REFS.keys():
        results += expand(
            rules.bam_to_paf.output.paf,
            sm=sm,
            hap=["hap1", "hap2"],
            asm_type=asm_type,
            ref=ref,
        )
        # Add merged diploid BAM
        results += expand(
            rules.merge_haplotype_bam.output.bam,
            sm=sm,
            asm_type=asm_type,
            ref=ref,
        )
        # Add phased variant VCF (if enabled)
        if config.get("call_variants", True):
            results += expand(
                rules.merge_variants.output.vcf,
                sm=sm,
                asm_type=asm_type,
                ref=ref,
            )


rule all:
    input:
        results,
